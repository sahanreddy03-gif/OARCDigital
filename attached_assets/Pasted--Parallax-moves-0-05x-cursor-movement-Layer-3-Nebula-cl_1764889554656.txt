```
- Parallax: moves 0.05x cursor movement

Layer 3:
- Nebula clouds (purple/pink gradients, blur: 60px)
- Very slow drift animation (120s)
- Parallax: moves 0.1x cursor movement

Layer 4:
- Larger nebula formations (opacity: 0.2)
- Radial gradients: rgba(139,92,246,0.1)
- Parallax: moves 0.2x cursor movement

Layer 5 (Closest):
- Subtle fog overlay
- linear-gradient(180deg, transparent, rgba(0,0,0,0.3))
- Parallax: moves 0.3x cursor movement

ALL LAYERS:
- Respond to cursor position (3D tilt effect)
- Create depth illusion
- Smooth transitions (transition: transform 0.3s ease-out)

═══════════════════════════════════════════════════════════
LEFT SIDE: 3D FLOATING WORK GALLERY
═══════════════════════════════════════════════════════════

CONTAINER:
position: absolute;
left: 0;
width: 40%;
height: 100%;
transform-style: preserve-3d;

WORK CARDS (15-20 pieces):

Card Structure:
.work-card {
  position: absolute;
  width: 280px;
  height: 380px;
  background: white;
  border-radius: 20px;
  box-shadow: 0 20px 60px rgba(0,0,0,0.3);
  transform-style: preserve-3d;
  cursor: pointer;
  transition: all 0.6s cubic-bezier(0.4, 0, 0.2, 1);
}

3D POSITIONING:
Each card has unique:
- X: Random between 5% - 35%
- Y: Random between 10% - 80%
- Z: Random between -400px and 200px (depth)
- rotateX: Random -15deg to 15deg
- rotateY: Random -20deg to 20deg
- rotateZ: Random -5deg to 5deg

DEPTH EFFECTS:
- Cards closer (higher Z): Larger, sharper
- Cards farther (lower Z): Smaller, blurred

Calculate scale:
scale = 1 + (z / 1000);

Calculate blur:
filter: blur(calc(max(0, -1 * var(--z) / 100) * 1px));

ANIMATION:
@keyframes float-3d {
  0%, 100% {
    transform: 
      translate3d(var(--x), var(--y), var(--z))
      rotateX(var(--rx))
      rotateY(var(--ry))
      rotateZ(var(--rz));
  }
  50% {
    transform: 
      translate3d(var(--x), calc(var(--y) - 30px), var(--z))
      rotateX(calc(var(--rx) + 5deg))
      rotateY(calc(var(--ry) + 5deg))
      rotateZ(calc(var(--rz) + 2deg));
  }
}

Apply with random duration: 8s to 15s per card

MAGNETIC CURSOR EFFECT:
On mousemove, calculate distance from cursor to card.
If distance < 300px:
  Apply tilt toward cursor:
  
  const dx = cursorX - cardCenterX;
  const dy = cursorY - cardCenterY;
  const distance = Math.sqrt(dx*dx + dy*dy);
  const strength = (300 - distance) / 300;
  
  card.style.transform = `
    translate3d(${x}px, ${y}px, ${z}px)
    rotateY(${(dx / distance) * strength * 20}deg)
    rotateX(${-(dy / distance) * strength * 20}deg)
  `;

HOVER STATE:
.work-card:hover {
  transform: 
    translate3d(var(--x), var(--y), calc(var(--z) + 150px))
    rotateY(0deg) 
    rotateX(0deg) 
    scale(1.15);
  box-shadow: 
    0 40px 100px rgba(255,107,157,0.4),
    0 0 60px rgba(255,107,157,0.3);
  z-index: 100;
}

CONTENT:
- Real campaign images/videos
- Videos: autoplay, loop, muted
- White card background
- Subtle info overlay on hover

═══════════════════════════════════════════════════════════
CENTER: DIMENSIONAL PORTAL
═══════════════════════════════════════════════════════════

CONTAINER:
position: absolute;
left: 50%;
top: 40%;
transform: translate(-50%, -50%);
width: 500px;
height: 500px;
transform-style: preserve-3d;
perspective: 1500px;

PORTAL STRUCTURE:

1. SPINNING RINGS (5 rings):

.portal-ring {
  position: absolute;
  inset: 0;
  border: 4px solid transparent;
  border-radius: 50%;
  
  /* Gradient border */
  background: 
    linear-gradient(white, white) padding-box,
    linear-gradient(
      calc(var(--rotation) * 1deg),
      #FF6B9D,
      #8B5CF6,
      #00FF41,
      #FF6B9D
    ) border-box;
  
  /* 3D depth */
  transform: 
    translateZ(calc(var(--ring-index) * -80px))
    rotateX(70deg)
    rotateZ(calc(var(--rotation) * 1deg));
  
  /* Glow */
  box-shadow: 
    0 0 30px rgba(139,92,246,0.5),
    inset 0 0 30px rgba(139,92,246,0.3);
}

Ring sizes (inset):
Ring 1: inset: 0; (largest)
Ring 2: inset: 40px;
Ring 3: inset: 80px;
Ring 4: inset: 120px;
Ring 5: inset: 160px; (smallest, deepest)

Animation:
Each ring rotates at different speed:
Ring 1: 12s
Ring 2: 10s
Ring 3: 8s
Ring 4: 6s
Ring 5: 4s

@keyframes spin-ring {
  from { 
    transform: 
      translateZ(calc(var(--ring-index) * -80px))
      rotateX(70deg)
      rotateZ(0deg);
  }
  to { 
    transform: 
      translateZ(calc(var(--ring-index) * -80px))
      rotateX(70deg)
      rotateZ(360deg);
  }
}

2. PORTAL ENERGY FIELD:

.portal-energy {
  position: absolute;
  inset: -50%;
  background: radial-gradient(
    circle,
    rgba(139,92,246,0.4) 0%,
    rgba(255,107,157,0.3) 30%,
    rgba(0,255,65,0.2) 60%,
    transparent 80%
  );
  filter: blur(60px);
  mix-blend-mode: screen;
  animation: energy-pulse 3s ease-in-out infinite;
}

@keyframes energy-pulse {
  0%, 100% {
    opacity: 0.6;
    transform: scale(1);
  }
  50% {
    opacity: 1;
    transform: scale(1.1);
  }
}

3. DISTORTION EFFECT:

.portal-distortion {
  position: absolute;
  inset: 0;
  border-radius: 50%;
  backdrop-filter: blur(8px);
  -webkit-backdrop-filter: blur(8px);
  
  /* Ripple effect */
  animation: distortion-ripple 4s ease-in-out infinite;
}

@keyframes distortion-ripple {
  0%, 100% {
    transform: scale(1);
    opacity: 0.5;
  }
  50% {
    transform: scale(1.05);
    opacity: 0.8;
  }
}

4. CENTER LOGO:

.portal-logo {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%) translateZ(100px);
  width: 120px;
  z-index: 10;
  
  filter: drop-shadow(0 0 40px rgba(255,255,255,0.8));
  animation: logo-float 4s ease-in-out infinite;
}

@keyframes logo-float {
  0%, 100% {
    transform: translate(-50%, -50%) translateZ(100px) rotateY(0deg);
  }
  50% {
    transform: translate(-50%, -50%) translateZ(120px) rotateY(5deg);
  }
}

5. HEADLINE (Below Portal):

.split-headline {
  position: absolute;
  top: 140%;
  left: 50%;
  transform: translateX(-50%);
  display: flex;
  gap: 32px;
  align-items: center;
  white-space: nowrap;
  font-size: clamp(48px, 6vw, 72px);
  font-weight: 900;
}

.creative-text {
  background: linear-gradient(135deg, #FF6B9D, #C77DFF);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  filter: drop-shadow(0 0 30px rgba(255,107,157,0.6));
  animation: text-glow-pulse 3s ease-in-out infinite;
}

.fusion-symbol {
  color: white;
  font-size: 1.2em;
  animation: symbol-rotate 8s linear infinite;
}

@keyframes symbol-rotate {
  from { transform: rotate(0deg); }
  to { transform: rotate(360deg); }
}

.ai-text {
  background: linear-gradient(135deg, #00FF41, #00D4FF);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  filter: drop-shadow(0 0 30px rgba(0,255,65,0.6));
  animation: text-glow-pulse 3s ease-in-out infinite 1.5s;
}

@keyframes text-glow-pulse {
  0%, 100% { filter: drop-shadow(0 0 30px currentColor); }
  50% { filter: drop-shadow(0 0 50px currentColor); }
}

6. SUBHEADLINE:

.subheadline {
  position: absolute;
  top: 180%;
  left: 50%;
  transform: translateX(-50%);
  font-size: clamp(20px, 2.5vw, 32px);
  color: rgba(255,255,255,0.95);
  text-align: center;
  letter-spacing: 0.5px;
  text-shadow: 0 2px 20px rgba(0,0,0,0.5);
}

7. PROOF METRICS:

.proof-line {
  position: absolute;
  top: 200%;
  left: 50%;
  transform: translateX(-50%);
  font-size: clamp(16px, 1.8vw, 20px);
  color: rgba(255,255,255,0.85);
  text-align: center;
  max-width: 700px;
  line-height: 1.6;
}

.metric-highlight {
  font-weight: 700;
  color: #FF6B35;
  text-shadow: 0 0 20px rgba(255,107,53,0.5);
}

8. CTA BUTTON:

.portal-cta {
  position: absolute;
  top: 230%;
  left: 50%;
  transform: translateX(-50%);
  
  padding: 24px 64px;
  font-size: 22px;
  font-weight: 700;
  
  background: linear-gradient(135deg, #FF6B35, #C77DFF);
  color: white;
  border: none;
  border-radius: 16px;
  cursor: pointer;
  
  box-shadow: 
    0 8px 32px rgba(255,107,53,0.4),
    0 0 60px rgba(199,125,255,0.3);
  
  transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
}

.portal-cta::before {
  content: '';
  position: absolute;
  inset: -2px;
  border-radius: 18px;
  padding: 2px;
  background: linear-gradient(135deg, #FF6B9D, #8B5CF6, #00FF41);
  -webkit-mask: 
    linear-gradient(#fff 0 0) content-box, 
    linear-gradient(#fff 0 0);
  -webkit-mask-composite: xor;
  mask-composite: exclude;
  opacity: 0;
  transition: opacity 0.3s;
}

.portal-cta:hover::before {
  opacity: 1;
}

.portal-cta:hover {
  transform: translateX(-50%) translateY(-8px) scale(1.05);
  box-shadow: 
    0 16px 48px rgba(255,107,53,0.5),
    0 0 80px rgba(199,125,255,0.4);
}

═══════════════════════════════════════════════════════════
RIGHT SIDE: AI NEURAL REACTOR
═══════════════════════════════════════════════════════════

CONTAINER:
position: absolute;
right: 0;
width: 40%;
height: 100%;
background: radial-gradient(
  circle at 60% 50%,
  rgba(0,255,65,0.05),
  transparent
);

NEURAL NETWORK (Canvas):

Canvas: 600px × 800px
Position: Centered in right side

Neural Network Structure:
- 5 layers of nodes
- 8 nodes per layer
- Fully connected
- 3D positioning (z-depth varies)

Node Class:
class NeuralNode {
  constructor(x, y, z, layer) {
    this.x = x;
    this.y = y;
    this.z = z;
    this.layer = layer;
    this.active = false;
    this.activation = 0;
    this.connections = [];
  }
  
  activate(strength = 1) {
    this.active = true;
    this.activation = strength;
    
    // Propagate to next layer with delay
    setTimeout(() => {
      this.connections.forEach(node => {
        node.activate(strength * 0.9);
      });
    }, 100);
  }
  
  update() {
    // Decay activation
    this.activation *= 0.95;
    if (this.activation < 0.01) {
      this.active = false;
      this.activation = 0;
    }
  }
  
  render(ctx) {
    // 3D to 2D projection
    const scale = 1 + (this.z / 500);
    const x = this.x * scale;
    const y = this.y * scale;
    const size = 8 * scale;
    
    // Render connections first
    this.connections.forEach(target => {
      if (this.active && target.active) {
        const targetScale = 1 + (target.z / 500);
        const tx = target.x * targetScale;
        const ty = target.y * targetScale;
        
        // Gradient line
        const gradient = ctx.createLinearGradient(x, y, tx, ty);
        gradient.addColorStop(0, `rgba(0,255,65,${this.activation})`);
        gradient.addColorStop(1, `rgba(0,255,65,${target.activation})`);
        
        ctx.strokeStyle = gradient;
        ctx.lineWidth = 2 * scale;
        ctx.shadowBlur = 10;
        ctx.shadowColor = '#00FF41';
        
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(tx, ty);
        ctx.stroke();
        
        // Data pulse
        if (this.active) {
          const pulsePos = (Date.now() % 500) / 500;
          const px = x + (tx - x) * pulsePos;
          const py = y + (ty - y) * pulsePos;
          
          ctx.fillStyle = '#00FF41';
          ctx.shadowBlur = 20;
          ctx.beginPath();
          ctx.arc(px, py, 3, 0, Math.PI * 2);
          ctx.fill();
        }
      }
    });
    
    // Render node
    ctx.fillStyle = this.active 
      ? `rgba(0,255,65,${this.activation})`
      : 'rgba(0,255,65,0.2)';
    ctx.shadowBlur = this.active ? 20 : 5;
    ctx.shadowColor = '#00FF41';
    ctx.beginPath();
    ctx.arc(x, y, size, 0, Math.PI * 2);
    ctx.fill();
    
    // Inner glow
    if (this.active) {
      ctx.fillStyle = 'rgba(255,255,255,0.8)';
      ctx.shadowBlur = 0;
      ctx.beginPath();
      ctx.arc(x, y, size * 0.4, 0, Math.PI * 2);
      ctx.fill();
    }
  }
}

Network Initialization:
const layers = 5;
const nodesPerLayer = 8;
const nodes = [];

for (let layer = 0; layer < layers; layer++) {
  for (let i = 0; i < nodesPerLayer; i++) {
    const x = 100 + layer * 120;
    const y = 100 + i * 80;
    const z = Math.sin(layer * 0.5 + i * 0.3) * 100;
    const node = new NeuralNode(x, y, z, layer);
    nodes.push(node);
    
    // Connect to next layer
    if (layer < layers - 1) {
      const nextLayerStart = (layer + 1) * nodesPerLayer;
      for (let j = 0; j < nodesPerLayer; j++) {
        node.connections.push(nodes[nextLayerStart + j]);
      }
    }
  }
}

Continuous Activation:
setInterval(() => {
  // Random input layer activation
  const inputNodes = nodes.filter(n => n.layer === 0);
  const randomNode = inputNodes[Math.floor(Math.random() * inputNodes.length)];
  randomNode.activate(1);
}, 1500);

Animation Loop:
function animate() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  // Update all nodes
  nodes.forEach(node => node.update());
  
  // Render connections and nodes
  nodes.forEach(node => node.render(ctx));
  
  requestAnimationFrame(animate);
}

CODE TERMINAL:

.code-terminal {
  position: absolute;
  top: 10%;
  right: 10%;
  width: 400px;
  max-height: 300px;
  background: rgba(13,17,23,0.8);
  border: 1px solid rgba(0,255,65,0.2);
  border-radius: 8px;
  padding: 20px;
  font-family: 'Fira Code', 'Courier New', monospace;
  font-size: 13px;
  overflow: hidden;
  backdrop-filter: blur(10px);
}

Code Lines (typing effect):
const codeSnippets = [
  "const aiEngine = new NeuralOptimizer();",
  "aiEngine.analyze(creativeContent);",
  "const insights = aiEngine.predict();",
  "const optimized = aiEngine.enhance(insights);",
  "revenue.increase(optimized.impact);"
];

let currentLine = 0;
let currentChar = 0;

function typeCode() {
  if (currentLine >= codeSnippets.length) {
    currentLine = 0;
    // Clear terminal
    setTimeout(() => {
      terminal.innerHTML = '<span class="prompt">$ </span>';
      typeCode();
    }, 2000);
    return;
  }
  
  const line = codeSnippets[currentLine];
  const char = line[currentChar];
  
  if (currentChar === 0) {
    terminal.innerHTML += '<br><span class="code-line">';
  }
  
  terminal.innerHTML += char;
  currentChar++;
  
  if (currentChar >= line.length) {
    terminal.innerHTML += '</span>';
    currentChar = 0;
    currentLine++;
    setTimeout(typeCode, 500);
  } else {
    setTimeout(typeCode, 50);
  }
}

Style:
.code-line {
  color: #00FF41;
  text-shadow: 0 0 10px rgba(0,255,65,0.5);
}

.prompt {
  color: #8B5CF6;
}

DATA STREAMS:

.data-stream {
  position: absolute;
  width: 2px;
  height: 100px;
  background: linear-gradient(
    to bottom,
    transparent,
    #00FF41,
    transparent
  );
  box-shadow: 0 0 10px #00FF41;
  animation: stream-flow 2s linear infinite;
}

@keyframes stream-flow {
  from {
    transform: translateY(-100%);
    opacity: 0;
  }
  50% {
    opacity: 1;
  }
  to {
    transform: translateY(calc(100vh + 100%));
    opacity: 0;
  }
}

Generate 10-15 streams:
- Random X positions across right side
- Staggered animation delays
- Different speeds (1.5s - 3s)

═══════════════════════════════════════════════════════════
SERVICE CARDS: ORBITAL SYSTEM
═══════════════════════════════════════════════════════════

CONCEPT: 8 cards orbit around the portal in 3D space

Card Structure:
.service-card {
  position: absolute;
  width: 280px;
  padding: 32px;
  background: rgba(255,255,255,0.95);
  border-radius: 20px;
  box-shadow: 0 12px 40px rgba(0,0,0,0.2);
  cursor: pointer;
  transform-style: preserve-3d;
  transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
}

Content:
- Icon (48px, colorful)
- Title (20px, bold)
- Brief description (14px)
- Small arrow indicator

Orbital Mechanics:
class OrbitingServiceCard {
  constructor(index, total, portalX, portalY) {
    this.index = index;
    this.angle = (index / total) * Math.PI * 2;
    this.radius = 700; // Distance from portal
    this.portalX = portalX;
    this.portalY = portalY;
    this.speed = 0.0003; // Slow rotation
    this.depthPhase = index * (Math.PI * 2 / total);
  }
  
  update(time) {
    this.angle += this.speed;
    
    // Calculate position
    this.x = this.portalX + Math.cos(this.angle) * this.radius;
    this.y = this.portalY + Math.sin(this.angle) * this.radius;
    
    // Z-depth creates elliptical orbit
    this.z = Math.sin(this.angle + this.depthPhase) * 300;
    
    // Scale based on depth
    this.scale = 0.8 + (this.z + 300) / 600 * 0.4;
    
    // Blur based on depth
    this.blur = Math.max(0, -this.z / 150);
    
    // Z-index based on depth
    this.zIndex = Math.floor(100 + this.z);
  }
  
  render(element) {
    element.style.transform = `
      translate3d(${this.x}px, ${this.y}px, ${this.z}px)
      scale(${this.scale})
      rotateY(${-this.angle}rad)
    `;
    element.style.filter = `blur(${this.blur}px)`;
    element.style.zIndex = this.zIndex;
    element.style.opacity = 0.5 + this.scale * 0.5;
  }
}

Initialize 8 cards:
const services = [
  "Media Buying",
  "Website Design",
  "Influencer Marketing",
  "Rapid Idea Testing",
  "Lead Generation",
  "Creative Ad Campaigns",
  "Revenue Reporting",
  "Funnel Automation"
];

const orbiting = services.map((service, i) => 
  new OrbitingServiceCard(i, services.length, portalX, portalY)
);

Animation loop:
function animateOrbit() {
  const time = Date.now() * 0.001;
  orbiting.forEach((card, i) => {
    card.update(time);
    card.render(serviceElements[i]);
  });
  requestAnimationFrame(animateOrbit);
}

Hover Effect:
.service-card:hover {
  transform: 
    translate3d(var(--x), var(--y), calc(var(--z) + 100px))
    scale(calc(var(--scale) * 1.15))
    rotateY(0deg);
  box-shadow: 0 24px 80px rgba(0,0,0,0.3);
  filter: blur(0px) !important;
  opacity: 1 !important;
  z-index: 1000 !important;
}

Click Behavior:
- Stop orbit
- Expand card
- Show full service details
- Dim other cards

═══════════════════════════════════════════════════════════
PARTICLE SYSTEM: QUANTUM FIELD
═══════════════════════════════════════════════════════════

Canvas: Full viewport overlay

Particle Types:

1. CREATIVE PARTICLES (Pink):
   - Spawn from work cards
   - Flow toward portal
   - Spiral inward
   - Merge at center

2. AI PARTICLES (Green):
   - Spawn from neural nodes
   - Follow network paths
   - Pulse with data
   - Converge at portal

3. FUSION PARTICLES (White/Rainbow):
   - Spawn at portal
   - Explode outward
   - Fade over time
   - Rainbow trail

Particle Class:
class QuantumParticle {
  constructor(type, x, y, z) {
    this.type = type;
    this.x = x;
    this.y = y;
    this.z = z;
    this.vx = (Math.random() - 0.5) * 2;
    this.vy = (Math.random() - 0.5) * 2;
    this.vz = (Math.random() - 0.5) * 2;
    this.life = 1.0;
    this.maxLife = 1.0;
    this.trail = [];
    this.maxTrail = 20;
  }
  
  update(portalX, portalY, cursorX, cursorY) {
    // Portal gravity
    const dx = portalX - this.x;
    const dy = portalY - this.y;
    const distance = Math.sqrt(dx*dx + dy*dy);
    
    if (distance > 50) {
      const force = 150 / (distance * distance);
      this.vx += (dx / distance) * force;
      this.vy += (dy / distance) * force;
    }
    
    // Cursor magnetic field
    const cdx = cursorX - this.x;
    const cdy = cursorY - this.y;
    const cdist = Math.sqrt(cdx*cdx + cdy*cdy);
    
    if (cdist < 200) {
      const repel = (200 - cdist) / 200 * 3;
      this.vx += (cdx / cdist) * repel;
      this.vy += (cdy / cdist) * repel;
    }
    
    // Apply velocity
    this.x += this.vx;
    this.y += this.vy;
    this.z += this.vz;
    
    // Drag
    this.vx *= 0.98;
    this.vy *= 0.98;
    this.vz *= 0.98;
    
    // Update trail
    this.trail.push({ x: this.x, y: this.y, z: this.z });
    if (this.trail.length > this.maxTrail) {
      this.trail.shift();
    }
    
    // Decay life
    this.life -= 0.005;
    
    // Check portal collision
    if (distance < 50) {
      this.reachedPortal();
    }
  }
  
  reachedPortal() {
    // Spawn fusion particles
    for (let i = 0; i < 5; i++) {
      const angle = Math.random() * Math.PI * 2;
      const speed = 3 + Math.random() * 4;
      const fx = this.x + Math.cos(angle) * speed;
      const fy = this.y + Math.sin(angle) * speed;
      const fz = (Math.random() - 0.5) * speed;
      particles.push(new QuantumParticle('fusion', fx, fy, fz));
    }
    this.life = 0; // Remove self
  }
  
  render(ctx) {
    if (this.life <= 0) return;
    
    // Scale based on Z
    const scale = 1 + (this.z / 500);
    const size = 3 * scale;
    const alpha = this.life;
    
    // Render trail
    ctx.beginPath();
    this.trail.forEach((pos, i) => {
      const trailScale = 1 + (pos.z / 500);
      const tx = pos.x * trailScale;
      const ty = pos.y * trailScale;
      const trailAlpha = (i / this.trail.length) * alpha;
      
      if (i === 0) {
        ctx.moveTo(tx, ty);
      } else {
        ctx.lineTo(tx, ty);
      }
      
      ctx.globalAlpha = trailAlpha;
    });
    
    ctx.strokeStyle = this.getColor();
    ctx.lineWidth = 2 * scale;
    ctx.shadowBlur = 15;
    ctx.shadowColor = this.getColor();
    ctx.stroke();
    
    // Render particle
    ctx.globalAlpha = alpha;
    ctx.fillStyle = this.getColor();
    ctx.shadowBlur = 20;
    ctx.beginPath();
    ctx.arc(this.x * scale, this.y * scale, size, 0, Math.PI * 2);
    ctx.fill();
  }
  
  getColor() {
    switch(this.type) {
      case 'creative': return '#FF6B9D';
      case 'ai': return '#00​​​​​​​​​​​​​​​​
```